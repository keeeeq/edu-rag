# 知识点 7: 文档加载器

> 📍 **核心文件**: `rag_qa/edu_document_loaders/`  
> ⏱️ **学习时间**: 约 15-20 分钟  
> 🎯 **重要性**: ⭐⭐ (工具性组件)

---

## 🤔 核心问题：为什么需要文档加载器？

### 文档格式多样性

```
RAG 系统需要处理各种格式的文档：

📄 PDF  → 需要提取文字（可能包含扫描图片）
📝 Word → 需要解析 .docx 格式
📊 PPT  → 需要提取幻灯片文本
🖼️ 图片 → 需要 OCR 识别文字
📋 TXT  → 直接读取
```

**不同格式需要不同的加载器**：
- ❌ 不能用一个方法处理所有格式
- ✅ 每种格式有专门的加载器

---

## 第一部分：文档加载器体系

### 📊 加载器分类

项目中的加载器位于 `edu_document_loaders/` 目录：

| 加载器 | 支持格式 | 特点 |
|--------|---------|------|
| **OCRPDFLoader** | `.pdf` | 支持 OCR，可识别扫描件 |
| **OCRDOCLoader** | `.docx` | 支持 Word 文档 |
| **OCRPPTLoader** | `.ppt`, `.pptx` | 支持 PPT 文档 |
| **OCRIMGLoader** | `.jpg`, `.png` | 图片 OCR 识别 |
| **TextLoader** | `.txt` | 纯文本文件（LangChain 内置） |

### 🔗 在 `document_processor.py` 中的使用

**代码位置**: 第 30-45 行

```python
document_loaders = {
    ".txt": TextLoader,
    ".pdf": OCRPDFLoader,    # ← 自定义 OCR 加载器
    ".docx": OCRDOCLoader,
    ".ppt": OCRPPTLoader,
    ".pptx": OCRPPTLoader,
    ".jpg": OCRIMGLoader,
    ".png": OCRIMGLoader
}

# 使用方式
file_extension = os.path.splitext(file_path)[1].lower()
if file_extension in document_loaders:
    loader_class = document_loaders[file_extension]
    loader = loader_class(file_path)
    documents = loader.load()  # 返回 Document 对象列表
```

---

## 第二部分：OCR 加载器的核心价值

### 💡 为什么需要 OCR？

**普通 PDF 加载器 vs OCR PDF 加载器**：

| 类型 | 普通加载器 | OCR 加载器 |
|------|----------|-----------|
| **纯文字 PDF** | ✅ 能提取 | ✅ 能提取 |
| **扫描件 PDF** | ❌ 只能看到图片 | ✅ OCR 识别文字 |
| **图文混排** | ⚠️ 只提取文字部分 | ✅ 图片部分也识别 |
| **手写文档** | ❌ 无法识别 | ✅ OCR 识别（准确度取决于手写质量） |

### 🎯 OCR 加载器的设计思路

```python
class OCRPDFLoader(BaseLoader):
    def load(self):
        # 1. 尝试直接提取文字（快速）
        text = extract_text_directly(self.file_path)
        
        # 2. 如果提取不到或内容太少，使用 OCR（慢但准确）
        if len(text) < 50:
            text = ocr_extract(self.file_path)
        
        # 3. 返回 Document 对象
        return [Document(page_content=text, metadata={...})]
```

**核心思想**：
- ✅ 先快后慢：先尝试快速方法
- ✅ 兜底策略：快速方法失败时用 OCR
- ✅ 统一接口：所有加载器返回相同格式

---

## 第三部分：文档加载流程

### 🔄 完整流程

**代码位置**: `document_processor.py` 第 47-103 行

```python
def load_documents_from_directory(directory_path):
    documents = []
    
    # 步骤1: 遍历目录
    for root, _, files in os.walk(directory_path):
        for file in files:
            file_path = os.path.join(root, file)
            file_extension = os.path.splitext(file_path)[1].lower()
            
            # 步骤2: 选择合适的加载器
            if file_extension in document_loaders:
                loader_class = document_loaders[file_extension]
                
                # 步骤3: 加载文档
                try:
                    loader = loader_class(file_path)
                    loaded_docs = loader.load()
                    
                    # 步骤4: 添加元数据
                    for doc in loaded_docs:
                        doc.metadata["source"] = extract_source(directory_path)
                        doc.metadata["file_path"] = file_path
                        doc.metadata["timestamp"] = datetime.now().isoformat()
                    
                    documents.extend(loaded_docs)
                    logger.info(f"成功加载文件: {file_path}")
                
                except Exception as e:
                    logger.error(f"加载文件 {file_path} 失败: {e}")
    
    return documents
```

### 💡 设计要点

#### 1. 自动文件类型识别

```python
file_extension = os.path.splitext(file_path)[1].lower()
→ "AI课程.pdf" → ".pdf"
→ "简历.docx" → ".docx"
```

#### 2. 统一的错误处理

```python
try:
    documents = loader.load()
except Exception as e:
    logger.error(f"加载失败: {e}")
    # 继续处理下一个文件，不中断整个流程
```

#### 3. 自动元数据添加

```python
doc.metadata = {
    "source": "ai",  # 从目录名提取（ai_data → ai）
    "file_path": "...\\ai_data\\LLM基础知识.pdf",
    "timestamp": "2026-01-04T15:00:00"
}
```

**元数据的作用**：
- ✅ 文档溯源：知道文本来自哪个文件
- ✅ 学科过滤：根据 source 过滤检索结果
- ✅ 调试排查：快速定位问题文档

---

## 第四部分：LangChain Document 对象

### 📦 Document 对象结构

```python
from langchain_core.documents import Document

doc = Document(
    page_content="AI课程介绍...",  # 文档内容（字符串）
    metadata={                      # 元数据（字典）
        "source": "ai",
        "file_path": "...\\ai_data\\LLM基础知识.pdf",
        "timestamp": "2026-01-04T15:00:00",
        "page": 1,  # 如果是多页文档
        ...
    }
)
```

### 💡 为什么用 Document 对象？

**vs 直接用字符串**：

| 对比项 | 字符串 | Document 对象 |
|--------|--------|--------------|
| 内容存储 | ✅ | ✅ |
| 元数据 | ❌ | ✅ |
| 标准化 | ❌ | ✅（LangChain 标准） |
| 工具兼容性 | ❌ | ✅（与 LangChain 生态兼容） |

**统一接口的价值**：
```python
# 所有加载器返回相同类型
pdf_docs = OCRPDFLoader("file.pdf").load()      # → [Document]
word_docs = OCRDOCLoader("file.docx").load()    # → [Document]
img_docs = OCRIMGLoader("image.jpg").load()     # → [Document]

# 后续处理代码统一
for doc in all_docs:  # 无需关心来源
    chunks = text_splitter.split_documents([doc])
```

---

## 第五部分：实际应用案例

### 案例 1：处理混合格式文档库

```python
data/
├── ai_data/
│   ├── LLM基础知识.pdf        ← OCRPDFLoader
│   ├── 课程大纲.docx          ← OCRDOCLoader
│   ├── 介绍PPT.pptx          ← OCRPPTLoader
│   └── 宣传图.jpg            ← OCRIMGLoader
└── java_data/
    └── Java教程.txt          ← TextLoader

→ load_documents_from_directory() 自动选择正确的加载器
```

### 案例 2：处理扫描件 PDF

```
场景：老旧的纸质课程资料扫描成 PDF

普通 PDF 加载器：
→ text = ""  # 提取不到文字

OCR PDF 加载器：
→ text = "第一章：Python基础\n1.1 变量和数据类型..."
```

---

## 第六部分：扩展与优化

### 🔧 如何添加新的加载器？

**步骤**：

1. **创建加载器类**

```python
from langchain_core.document_loaders import BaseLoader
from langchain_core.documents import Document

class CustomLoader(BaseLoader):
    def __init__(self, file_path):
        self.file_path = file_path
    
    def load(self):
        # 1. 读取文件
        content = read_file(self.file_path)
        
        # 2. 处理内容
        processed_content = process(content)
        
        # 3. 返回 Document 对象
        return [Document(
            page_content=processed_content,
            metadata={"source": self.file_path}
        )]
```

2. **注册到加载器字典**

```python
document_loaders = {
    ...
    ".custom": CustomLoader,  # 添加新格式
}
```

### 💡 优化建议

#### 1. 分页加载大文件

```python
class OCRPDFLoader:
    def load(self):
        documents = []
        # 逐页加载，避免内存溢出
        for page_num in range(total_pages):
            page_text = extract_page(page_num)
            documents.append(Document(
                page_content=page_text,
                metadata={"page": page_num, ...}
            ))
        return documents
```

#### 2. 缓存 OCR 结果

```python
# OCR 很慢，缓存结果避免重复处理
if os.path.exists(cache_file):
    return load_from_cache()
else:
    result = ocr_extract(file_path)
    save_to_cache(result)
    return result
```

#### 3. 并行加载

```python
from concurrent.futures import ThreadPoolExecutor

def load_documents_parallel(directory_path):
    files = get_all_files(directory_path)
    
    with ThreadPoolExecutor(max_workers=4) as executor:
        results = executor.map(load_single_file, files)
    
    return list(results)
```

---

## ✅ 核心概念检查清单

- [x] **文档加载器的作用**：将不同格式文档转为统一的 Document 对象
- [x] **OCR 的价值**：处理扫描件和图片
- [x] **加载器选择**：根据文件扩展名自动选择
- [x] **Document 对象**：内容 + 元数据的标准化结构
- [x] **错误处理**：单个文件失败不影响整个流程
- [x] **元数据管理**：来源、路径、时间戳等

---

## 📊 文档加载器对比

| 类型 | 速度 | 准确性 | 适用场景 |
|------|------|--------|---------|
| **直接提取** | 快 | 高 | 纯文字文档 |
| **OCR** | 慢 | 中高 | 扫描件、图片 |
| **混合模式** | 中 | 高 | 未知类型（先尝试快速方法） |

---

## 🎓 总结

文档加载器是 RAG 系统的**数据入口**：

- ✅ **解决问题**：统一处理多种文档格式
- ✅ **设计原则**：统一接口、自动选择、错误容忍
- ✅ **核心价值**：把非结构化文档转为结构化数据

**关键理解**：
- 文档加载是数据处理的第一步
- OCR 可以处理图片和扫描件
- Document 对象是后续处理的基础

---

## 📚 知识点关联

```
知识点 7: 文档加载器
    ↓ 加载原始文档
知识点 4: 文档分割策略
    ↓ 切分成父子文档
知识点 1: 向量检索与存储
    ↓ 向量化并存储到 Milvus
知识点 2: RAG 核心流程
    ↓ 检索并生成答案
```

---

**上一个知识点**: [06_查询分类器.md](./06_查询分类器.md)  
**返回目录**: [README.md](./README.md)

---

**🎉 学习完成**: 恭喜您完成所有 7 个 RAG 核心知识点！

---

## 🎉 学习总结

您已经完成了 RAG 系统的完整学习：

### 🥇 Tier 1（核心必学）
- ✅ 知识点 1: 向量检索与存储
- ✅ 知识点 2: RAG 核心流程

### 🥈 Tier 2（重要优化）
- ✅ 知识点 3: 检索策略选择器
- ✅ 知识点 4: 文档分割策略

### 🥉 Tier 3（周边功能）
- ✅ 知识点 5: Prompt 工程
- ✅ 知识点 6: 查询分类器
- ✅ 知识点 7: 文档加载器

**接下来建议**：
1. 实战：自己修改参数，观察效果变化
2. 优化：针对您的场景调优 chunk size、检索策略等
3. 扩展：添加新的文档类型、新的检索策略

祝您在 RAG 开发中一帆风顺！ 🚀
