# 知识点 9: 会话管理与历史

> 📍 **核心文件**: `new_main.py` (IntegratedQASystem类)  
> ⏱️ **学习时间**: 约 30-40 分钟  
> 🎯 **重要性**: ⭐⭐⭐⭐ (多轮对话的基础)

---

## 🎯 核心概念:为什么需要会话管理?

### 问题场景

**无会话管理:**
```
用户: AI课程的学费是多少?
系统: AI课程学费为19800元

用户: 学时呢?
系统: ❌ 不知道你在问什么学时
```

**有会话管理:**
```
用户: AI课程的学费是多少?
系统: AI课程学费为19800元

用户: 学时呢?
系统: ✅ AI课程学时为6个月 (理解上下文)
```

---

## 第一部分:MySQL表设计

### 📊 conversations表结构

**代码位置**: `new_main.py` 第44-67行

```sql
CREATE TABLE IF NOT EXISTS conversations(
    id INT AUTO_INCREMENT PRIMARY KEY,
    session_id VARCHAR(36) NOT NULL,           -- 会话ID(UUID)
    question TEXT CHARACTER SET utf8mb4 NOT NULL,  -- 用户问题
    answer TEXT CHARACTER SET utf8mb4 NOT NULL,    -- 系统答案
    timestamp DATETIME NOT NULL,               -- 时间戳
    INDEX idx_session_id (session_id)         -- 索引加速查询
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**字段说明:**
- `session_id`: 唯一标识一次会话(如"a1b2c3d4-...")
- `question/answer`: 使用utf8mb4支持emoji
- `timestamp`: 记录对话时间
- `idx_session_id`: 索引提高查询速度

---

## 第二部分:会话历史存储

### 💾 更新会话历史

**代码位置**: `new_main.py` 第123-165行

```python
def update_session_history(self, session_id: str, question: str, answer: str):
    """更新会话历史到MySQL,保留最近5轮对话"""
    try:
        # 步骤1: 插入新的对话记录
        self.mysql_client.cursor.execute("""
            INSERT INTO conversations (session_id, question, answer, timestamp)
            VALUES (%s, %s, %s, NOW())
        """, (session_id, question, answer))
        
        # 步骤2: 获取更新后的对话历史
        history = self._fetch_recent_history(session_id)
        
        # 步骤3: 删除超出5轮的旧记录
        self.mysql_client.cursor.execute("""
            DELETE FROM conversations
            WHERE session_id = %s AND id NOT IN (
                SELECT id FROM (
                    SELECT id
                    FROM conversations
                    WHERE session_id = %s
                    ORDER BY timestamp DESC
                    LIMIT 5
                ) AS sub
            )
        """, (session_id, session_id))
        
        # 步骤4: 提交事务
        self.mysql_client.connect.commit()
        logger.info(f"会话 {session_id} 历史更新成功")
        
        return history
    except Exception as e:
        logger.error(f"更新会话历史失败: {e}")
        self.mysql_client.connect.rollback()
        raise
```

### 🔍 获取历史记录

**代码位置**: 第95-116行

```python
def _fetch_recent_history(self, session_id):
    """获取最近5轮对话历史"""
    try:
        self.mysql_client.cursor.execute("""
            SELECT question, answer
            FROM conversations
            WHERE session_id = %s
            ORDER BY timestamp DESC
            LIMIT 5
        """, (session_id,))
        
        # 转换为字典列表
        history = [
            {"question": row[0], "answer": row[1]} 
            for row in self.mysql_client.cursor.fetchall()
        ]
        
        # 反转顺序(最早的在前)
        return history[::-1]
    except Exception as e:
        logger.error(f"获取对话历史失败: {e}")
        return []
```

---

## 第三部分:会话历史的使用

### 🔗 与RAG集成

**代码位置**: `new_main.py` 第188-240行

```python
def query(self, query, source_filter=None, session_id=None):
    # 步骤1: 获取对话历史
    history = self.get_session_history(session_id) if session_id else []
    
    # 步骤2: BM25检索
    answer, need_rag = self.bm25_search.search(query, threshold=0.85)
    
    if answer:
        # BM25找到答案,更新历史
        if session_id:
            self.update_session_history(session_id, query, answer)
        yield answer, True
        
    elif need_rag:
        # RAG检索,传入历史
        collected_answer = ""
        for token in self.rag_system.generate_answer(
            query, 
            source_filter=source_filter, 
            history=history  # ← 传入历史
        ):
            collected_answer += token
            yield token, False
        
        # 更新历史
        if session_id:
            self.update_session_history(session_id, query, collected_answer)
```

### 💡 历史如何帮助RAG?

**RAG系统使用历史:**
```python
# rag_qa/core/rag_system.py
def generate_answer(self, query, history=None):
    # 构建包含历史的Prompt
    if history:
        context_with_history = "对话历史:\n"
        for h in history:
            context_with_history += f"Q: {h['question']}\nA: {h['answer']}\n"
        context_with_history += f"\n当前问题: {query}"
    
    # 传给LLM
    answer = self.llm(context_with_history)
```

**示例:**
```
对话历史:
Q: AI课程的学费是多少?
A: AI课程学费为19800元

当前问题: 学时呢?

→ LLM理解: 用户在问"AI课程的学时"
```

---

## 第四部分:会话管理策略

### 🎯 为什么只保留5轮?

**原因:**
1. **Token限制**: LLM输入有长度限制
2. **相关性**: 太久远的对话不相关
3. **性能**: 减少数据库存储和查询开销

**删除策略:**
```python
# 保留最近5轮
ORDER BY timestamp DESC LIMIT 5

# 删除其他记录
DELETE WHERE id NOT IN (最近5轮的id)
```

---

## 第五部分:清除历史

### 🗑️ 清除会话历史

**代码位置**: 第166-186行

```python
def clear_session_history(self, session_id: str) -> bool:
    """清除指定会话历史"""
    try:
        # 删除该会话的所有记录
        self.mysql_client.cursor.execute("""
            DELETE FROM conversations
            WHERE session_id = %s
        """, (session_id,))
        
        self.mysql_client.connect.commit()
        logger.info(f"会话 {session_id} 历史已清除")
        return True
    except Exception as e:
        logger.error(f"清除会话历史失败: {e}")
        self.mysql_client.connect.rollback()
        return False
```

**使用场景:**
- 用户点击"清除历史"按钮
- 开始新话题
- 隐私保护

---

## 第六部分:Web API集成

### 🌐 FastAPI端点

**代码位置**: `app.py`

```python
# 获取历史
@app.get("/api/history/{session_id}")
async def get_history(session_id: str):
    history = qa_system.get_session_history(session_id)
    return {"session_id": session_id, "history": history}

# 清除历史
@app.delete("/api/history/{session_id}")
async def clear_history(session_id: str):
    success = qa_system.clear_session_history(session_id)
    if success:
        return {"status": "success"}
    else:
        raise HTTPException(status_code=500)

# 创建新会话
@app.post("/api/create_session")
async def create_session():
    session_id = str(uuid.uuid4())
    return {"session_id": session_id}
```

---

## 第七部分:前端集成

### 🖥️ 前端显示历史

**代码位置**: `static/index.html`

```javascript
// 加载历史记录
async function loadHistory() {
    const response = await fetch(`/api/history/${currentSessionId}`);
    const data = await response.json();
    
    // 显示历史
    data.history.forEach(item => {
        addMessage('user', item.question);
        addMessage('system', item.answer);
    });
}

// 清除历史
async function clearHistory() {
    await fetch(`/api/history/${currentSessionId}`, {
        method: 'DELETE'
    });
    
    // 清空界面
    chatHistory.innerHTML = '';
}
```

---

## 第八部分:完整流程示例

### 🔄 多轮对话流程

```
第1轮:
用户: "AI课程的学费是多少?"
系统: "AI课程学费为19800元"
→ 存储到conversations表

第2轮:
用户: "学时呢?"
系统:
  1. 获取历史: [{Q: "AI课程的学费...", A: "19800元"}]
  2. 构建Prompt: "历史: Q:AI课程学费... 当前: 学时呢?"
  3. LLM理解: 用户问AI课程学时
  4. 回答: "AI课程学时为6个月"
→ 存储到conversations表

第3-5轮: 类似流程...

第6轮:
→ 自动删除第1轮的记录(只保留最近5轮)
```

---

## ✅ 核心概念检查清单

- [x] **conversations表**: 存储会话历史
- [x] **session_id**: 唯一标识会话
- [x] **保留5轮**: 平衡性能和上下文
- [x] **utf8mb4**: 支持emoji和特殊字符
- [x] **与RAG集成**: 历史传给LLM理解上下文
- [x] **Web API**: 前端可查询和清除历史

---

**上一个知识点**: [08_MySQL与BM25检索.md](./08_MySQL与BM25检索.md)  
**下一个知识点**: [10_FastAPI Web服务.md](./10_FastAPI Web服务.md)
